import axios from 'axios'
import { Observable, forkJoin, from, of, switchMap } from 'rxjs'
import type { Range } from '@/utils/range'
import type { Direction } from '@/utils/room'
const { floor } = Math

export type TileType2D = Direction | Range<0, 16>
/** A 2D tile set. It can be used to map Rooms to ImageBitmaps. */
export type TileSet2D = { size: number } & { [K in TileType2D]: ImageBitmap }
/** Holds the tile type definitions for a TileSet2D.
 * Tiles are read from left-to-right, from top-to-bottom from the tile-set image.
 * This array can be then be indexed to find the corresponding tile type */
export type TileSet2DTypeOrder = TileType2D[]
/** The default tile type order as seen in the test tile-set. Consists of 4Ã—4 maze tiles and a rightmost column for the cardinal player sprites */
export const defaultTileTypeOrder: TileSet2DTypeOrder = [
  6, // S + E
  14, // S + E + W
  12, // S + W
  4, // S
  'south',
  7, // S + N + E
  15, // S + N + E + W
  13, // S + N + W
  5, // S + N
  'east',
  3, // N + E
  11, // N + E + W
  9, // N + W
  1, // N
  'north',
  2, // E
  10, // E + W
  8, // W
  0, // No exits, not generated by current algorithm.
  'west'
]

export function getBitmapTileSet(
  uri: string,
  tileTypeOrder = defaultTileTypeOrder
): Observable<TileSet2D> {
  return from(axios.get<Blob>(uri, { responseType: 'blob' })).pipe(
    // Get the tileset image
    switchMap((response) => createImageBitmap(response.data)),
    switchMap((image) => {
      const size = floor(image.width / 5)
      return forkJoin(
        new Array(20).fill(image).reduce(
          (tileSet, img, ix) => ({
            ...tileSet,
            [tileTypeOrder[ix]]: createImageBitmap(
              img,
              size * floor(ix % 5),
              size * floor(ix / 5),
              size,
              size
            )
          }),
          { size: of(size) }
        ) as { [K in keyof TileSet2D]: Observable<TileSet2D[K]> }
      )
    })
  )
}
